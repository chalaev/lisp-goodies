#+TITLE: useful lisp macros and functions
#+AUTHOR: Oleg Shalaev
#+EMAIL:  oleg@chalaev.com
#+LaTeX_HEADER: \usepackage[russian,english]{babel}
#+LATEX_HEADER: \usepackage[letterpaper,hmargin={1.5cm,1.5cm},vmargin={1.3cm,2cm},nohead,nofoot]{geometry}
#+KEYWORDS: emacs, elisp, common lisp, macros, functions

* introduction
Notes:
1. Evaluation results are important part of this file, but =github= org-parser does not show them.
   (BTW [[https://notabug.org/shalaev/lisp-goodies/src/master/goodies.org][notabug does show them]] although unformatted.)  Consider opening this file in ~emacs~ instead of watching it online.
2. Sometimes a demonstration of a function might use the definition of another function defined below in this file or another
   file from the ~generated/~ directory, so you might need to =load= those first.

#+BEGIN_SRC lisp :tangle generated/shalaev.lisp
;; empty file needed for Makefile
#+END_SRC

* when-let
** Emacs Lisp
(in latest emacs) =when-let= and =when-let*= are defined in ~subr-x.el~:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el :shebang ";; -*-  lexical-binding: t; -*-"
(require 'subr-x)
#+END_SRC

=when-let= is one of my most-used macros; it is defined on top of (more general) =when-let-key=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(unless (< 25 (car (emacs-ver)))
(defmacro when-let-key(key vars &rest body)
  "when with let using standard let-notation, but every item in vars must be a list"
  (if (car vars)
  `(let ((,(caar vars) ,(cadar vars)))
     ,(if (cdr vars)
	  `(when (funcall ,key ,(caar vars))
	     ,(macroexpand-1 `(when-let-key ,key ,(cdr vars) ,@body)))
	(append `(when (funcall ,key ,(caar vars))) body)))
  (if (cdr vars)
      `(when ,(cadar vars)
	     ,(macroexpand-1 `(when-let-key ,key ,(cdr vars) ,@body)))
    (append `(when (funcall ,key ,(cadar vars))) body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el :shebang ";; -*-  lexical-binding: t; -*-"
(unless (< 25 (car (emacs-ver)))
(ert-deftest when-let-key()
(should (string= "aba" (when-let-key  #'identity ((a "a") (b (concat a "b")))
  (concat b "a"))))
(should (not (when-let-key  #'identity ((a "a") (b nil)) (concat "z" "a"))))
(should (not (when-let-key  #'identity ((c nil) (a "a") (b nil)) (concat "z" "a"))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(unless (< 25 (car (emacs-ver)))
(defmacro when-let*(vars &rest body)
  "when with let using standard let-notation"
`(when-let-key #'identity
   ,(mapcar #'(lambda(v) (if(listp v) v (list v nil))) vars)
    ,@body)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(unless (< 25 (car (emacs-ver)))
(ert-deftest when-let*()
(should (string= "aba" 
   (when-let* ((a "a") (b (concat a "b")))
      (concat b "a"))))
(should (not (when-let* ((a "a") (b)) (concat "z" "a"))))
(should (not (when-let* (c (a "a") b) (concat "z" "a"))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest when-let()
  "Testing here when-let and when-let* defined in subr-x.el"
(should (string= "ba" (when-let (a "a") (concat "b" a))))
(should (string= "ba" (when-let ((a "a")) (concat "b" a))))
(should (string= "ba" (when-let ((a "a") (b "b")) (concat b a))))
(should (string= "aba" (when-let ((a "a") (b (concat a "b"))) (concat b "a"))))
(should (string= "aba" (when-let* ((a "a") (b (concat a "b"))) (concat b "a")))))
#+END_SRC
← =when-let= is /almost/ identical to =when-let*=.

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest if-let*()
  "Testing here if-let* defined in subr-x.el"
:expected-result (if (< 25 (car (emacs-ver))) :passed :failed)
(should (= 1 (if-let* ((a 3)) 1 2)))
(should (= 12 (if-let* ((a 3) (b (* 3 a))) (+ a b) (- a b)))))
#+END_SRC

Later I wrote [[needs]] which is more general than =when-let=, and can replace it.

** Common Lisp
CL code is the same:
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro when-let (vars &rest body)
  "when with let using standard let-notation"
  (if (caar vars)
  `(let ((,(caar vars) ,(cadar vars)))
     ,(if (cdr vars)
	  `(when ,(caar vars)
	     ,(macroexpand-1 `(when-let ,(cdr vars) ,@body)))
	(append `(when ,(caar vars)) body)))
  (if (cdr vars)
      `(when ,(cadar vars)
	     ,(macroexpand-1 `(when-let ,(cdr vars) ,@body)))
    (append `(when ,(cadar vars)) body))))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest when-let
    (when-let ((x (identity :ok)))
      (setf x (cons x x))
      x)
  (:ok . :ok))
#+END_SRC

BTW [[https://stackoverflow.com/questions/5902847/how-do-i-apply-or-to-a-list-in-elisp/34946813#34946813][some people use]] ~eval~ instead of ~macroexpand-1~:
#+BEGIN_SRC lisp
(defun apply-macro (macro arg-list)
  (eval
   `(,macro ,@(loop for arg in arg-list collect `(quote ,arg)))))
#+END_SRC
Usage examples:
#+BEGIN_SRC lisp
(apply-macro 'and '(1 2 3))
(apply-macro 'and '(1 nil 3))
#+END_SRC

* if-let
** Emacs Lisp
Similarly to [[when-let]], (in latest emacs) =if-let= is defined in ~subr-x.el~.

Like =when-let=, macro =sif-let= is heavily used in my projects.
It is somewhat similar to =when-let=, but offers "else" clause:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro sif-let (vars ifyes &rest body)
  "if with let using standard let-notation"
  (let ((if-true (s-gensym "it")) (result (s-gensym "r")))
    `(let (,if-true ,result)
       (when-let* ,vars
		 (setf ,if-true t
		  ,result ,ifyes))
       (if ,if-true
	   ,result
	 ,@body))))
#+END_SRC

Usage example:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 
  '(sif-let ((x 1) (y (1+ x)))
     (+ x y) (- x y) (* x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let (it17 r18) (when-let ((x 1) (y (1+ x))) (setf it17 t r18 (+ x y))) (if it17 r18 (- x y) (* x y)))
:END:

** Common Lisp
My =if-let= has almost the same functionality, as [[https://common-lisp.net/project/alexandria/draft/alexandria.html][alexandria:if-let]]
except that instead of single =else-form= there can be multiple forms.

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro if-let (vars ifyes &rest body)
  "if with let using standard let-notation"
  (let ((if-true (gensym "it")) (result (gensym "r")))
    `(let (,if-true ,result)
       (when-let ,vars
		 (setf ,if-true t
		       ,result ,ifyes))
       (iff ,if-true ,result ,@body))))
#+END_SRC

Usage example:
#+BEGIN_SRC lisp :results drawer
(macroexpand-1 
  '(if-let ((x 1) (y (1+ x)))
     (+ x y) (- x y) (* x y)))
#+END_SRC

#+RESULTS:
:RESULTS:
(LET (#:|it597| #:|r598|)
  (WHEN-LET ((X 1) (Y (1+ X)))
    (SETF #:|it597| T
          #:|r598| (+ X Y)))
  (IFF #:|it597| #:|r598| (- X Y) (* X Y)))
:END:

Sometimes I need slightly changed versions of =if-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn-let (vars ifno &rest body)
  `(if-let ,vars
      (progn ,@body)
      ,ifno))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(ifn-let ((x (+ 1 2))) (+ 3 4) (+ 6 5) (+ 7 9))))
#+END_SRC

#+RESULTS:
:RESULTS:
(if-let ((x (+ 1 2))) (progn (+ 6 5) (+ 7 9)) (+ 3 4))
:END:

#+BEGIN_SRC emacs-lisp
(if-let ((x (+ 1 2))) (progn (+ 6 5) (+ 7 9)) (+ 3 4))
(if-let ((x (+ 1 2))) 1 2)
(if-let ((x t)) 1 2)
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro ifn-let (vars ifno &rest body)
  `(if-let ,vars
      (progn ,@body)
      ,ifno))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest if-let
    (if-let ((x (identity :ok)))
            x
            :bad)
  :ok)
(deftest ifn-let
    (ifn-let ((x (identity :ok)))
            :bad
x )
  :ok)
#+END_SRC

* needs
(This resembles standard =cl-assert= macro.)
New =needs= macro is gradually replacing =when-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro needs(vardefs &rest body)
  "unifying when-let and if-let"
  (let((vardef (car vardefs)))
;; was →    (if(and (listp vardef) (not (or (special-form-p (car vardef)) (functionp (car vardef)) (macrop (car vardef)))))
;; ← 03/22 replaced by
    (if(listp vardef)
    `(let ((,(car vardef) ,(cadr vardef)))
       ,(if (cddr vardef)
	    `(if ,(car vardef)
		,(if (cdr vardefs)
		     (macroexpand-1 `(needs ,(cdr vardefs) ,@body))
		   `(progn ,@body))
	       ,(car (cddr vardef)))
	  (append `(when ,(car vardef))
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body))))
    (append `(when ,vardef)
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest needs()
(should(string= "(let ((a (identity 1))) (when a (1+ a)))" (format "%s" (macroexpand-1 `(needs((a (identity 1))) (1+ a))))))
(should(string= "(let ((a (identity 1))) (if a (progn (1+ a)) (alarm)))" (format "%s" (macroexpand-1 `(needs((a (identity 1) (alarm))) (1+ a))))))
(should(= 2 (needs((a (identity 1) 100)) 2)))
(should(= 200 (needs((a (identity 1) 100) (b (identity nil) 200) (c (+ a 1) 300)) 55))))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro needs(vardefs &rest body)
  "unifying when-let and if-let"
  (let ((vardef (car vardefs)))
    (if (and (listp vardef) (not (functionp (car vardef))))
    `(let ((,(car vardef) ,(cadr vardef)))
       ,(if (cddr vardef)
	    `(if ,(car vardef)
		,(if (cdr vardefs)
		     (macroexpand-1 `(needs ,(cdr vardefs) ,@body))
		   `(progn ,@body))
	       ,(car (cddr vardef)))
	  (append `(when ,(car vardef))
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body))))
    (append `(when ,vardef)
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body)))))
#+END_SRC

=needs= acts similarly to =when-let= except that for every variable decalared in its header
it has an optional third argument – a form to be evaluated in case the variable turns out to be ~nil~.

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs
((x (f 1) (message "could not define x"))
 (y (g x) (message "could not define y")))
(message "let's rock")
(- x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((x (f 1))) (if x (let ((y (g x))) (if y (progn (message let's rock) (- x y)) (message could not define y))) (message could not define x)))
:END:

Formated output:
#+BEGIN_SRC emacs-lisp
(let ((x (f 1)))
  (if x
    (let ((y (g x)))
      (if y
        (progn
	  (message "let's rock")
	  (- x y))
	(message "could not define y")))
    (message could "not define x")))
#+END_SRC


For other usage examples, see [[https://github.com/chalaev/cloud][cloud]] project, e.g.:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs ((col-value (begins-with str (car column)) (bad-column "action" (cdr column))))
(aset action (cdr column) (car col-value))
(setf str (cdr col-value)))))
#+END_SRC

Sometimes I need a slightly changed version of =needs= that does not create a local variable,
setting the value of a global one instead:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro first2(ll) `(firstN ,ll 2))
(defmacro needs-set (vardefs &rest body)
  "needs with 'let' being replaced with 'setf'"
  (let ((vardef (car vardefs)))
    (if (cddr vardef)
      `(if-set (,(first2 vardef))
	  ,(if (cdr vardefs)
	       (macroexpand-1 `(needs-set ,(cdr vardefs) ,@body))
	     `(progn ,@body))
	  ,(caddr vardef))
      `(when-set (,(car vardefs))
	   ,(if (cdr vardefs)
	       (macroexpand-1 `(needs-set ,(cdr vardefs) ,@body))
	      `(progn ,@body))))))
#+END_SRC

Example #1:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs-set
((x (f 1) (message "did not set x"))
 (y (g x) (message "did not set y")))
(message "let's rock")
(- x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(if-set ((x (f 1)))
 (if-set ((y (g x)))
 (progn (message let's rock) (- x y))
 (message did not set y))
 (message did not set x))
:END:

and here is the formatted result:
#+BEGIN_SRC emacs-lisp
(if-set ((x (f 1)))
  (if-set ((y (g x)))
     (progn
       (message let's rock)
       (- x y))
     (message "did not set y"))
  (message "did not set x"))
#+END_SRC

Example #2 (from the [[https://github.com/chalaev/cloud][cloud project]]):
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs-set
  ((conf (read-conf* (local/config)))
   (remote/files (cdr (assoc "remote/files" conf)) (clog :error "specify 3-symbol contents name (remote/files) in %s" (local/config)))
   (N-CPU-cores (string-to-number
 (or
 (cdr (assoc "number-of-CPU-cores" conf))
 (clog :warning "specify number-of-CPU-cores in %s" (local/config)
 "1"))))
   (password (cdr (assoc "password" conf)) (clog :error "specify password in %s" (local/config)))
   (remote-dir (cdr (assoc "remote-directory" conf)) (clog :error "specify remote-directory in %s" (local/config))))
conf)))
#+END_SRC

#+RESULTS:
:RESULTS:
(when-set ((conf (read-conf* (local/config)))) (if-set ((remote/files (cdr (assoc remote/files conf)))) (when-set ((N-CPU-cores (string-to-number (or (cdr (assoc number-of-CPU-cores conf)) (clog :warning specify number-of-CPU-cores in %s (local/config) 1))))) (if-set ((password (cdr (assoc password conf)))) (if-set ((remote-dir (cdr (assoc remote-directory conf)))) (progn conf) (clog :error specify remote-directory in %s (local/config))) (clog :error specify password in %s (local/config)))) (clog :error specify 3-symbol contents name (remote/files) in %s (local/config))))
:END:
and here is the formatted result:
#+BEGIN_SRC emacs-lisp
(when-set ((conf (read-conf* (local/config))))
  (if-set ((remote/files (cdr (assoc remote/files conf))))
    (when-set ((N-CPU-cores (string-to-number (or (cdr (assoc number-of-CPU-cores conf)) (clog :warning specify number-of-CPU-cores in %s (local/config) 1)))))
      (if-set ((password (cdr (assoc password conf))))
        (if-set ((remote-dir (cdr (assoc remote-directory conf))))
	  (progn conf)
	  (clog :error specify remote-directory in %s (local/config)))
	(clog :error specify password in %s (local/config))))
    (clog :error specify 3-symbol contents name (remote/files) in %s (local/config))))
#+END_SRC

* directory-lock
=(directory-lock locked-dir by body...)= attempts to create directory =locked-dir=.
(Linux kernel is made in such a way, that if several processes are simultaneously trying to create nonexistent directory, *only one* of them succeeds.)

If the directory was sucessfully created,
1. file "by" is created inside it containing the string ~by~, and
2. forms ~body~ are evaluated.

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro directory-lock(locked-dir by &rest body)
(let ((LD (s-gensym "LD")) (lock-file (s-gensym "LF")))
`(let* ((,LD (file-name-as-directory ,locked-dir))
        (,lock-file (concat ,LD "by")))
 (make-directory ,LD t)
 (write-region ,by nil ,lock-file)
(prog1 (progn ,@body)
(delete-file ,lock-file)
(delete-directory ,LD)))))
#+END_SRC

*No matter how many processes are trying to lock the same directory simultaneously, at most one will succeed.*

Example – locking remote directory: 
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(directory-lock "/mnt/server/code-name" (system-name)
(body-1) (body-2))))
#+END_SRC

* (mostly) emacs lisp
** emacs configuration in ~/.emacs
*** "system" emacs functions
#+BEGIN_SRC emacs-lisp :tangle generated/local-packages.el :shebang ";; -*-  lexical-binding: t; -*-"
(unless (functionp 'caddr) (defun caddr(x) (car(cddr x)))); for emacs versions <26
(unless (functionp 'cadar) (defun cadar(x) (car (cdar x))))

(defun emacs-ver()
  (mapcar #'string-to-number (split-string
   (caddr (split-string (emacs-version))) "\\.")))
#+END_SRC

Let us upgrade =upgrade-make-temp-file= on older emacs versions, allowing this novel ~TEXT~ argument:
#+BEGIN_SRC emacs-lisp :tangle generated/local-packages.el
(unless (< 25 (car (emacs-ver)))
  (defun upgrade-make-temp-file(old-function PREFIX &optional DIR-FLAG SUFFIX TEXT)
    (let((FN (funcall old-function PREFIX DIR-FLAG SUFFIX)))
      (when (and TEXT (stringp TEXT))
      (write-region TEXT nil FN))
    FN))
(add-function :around (symbol-function 'make-temp-file) #'upgrade-make-temp-file))
#+END_SRC
← otherwise my =make-temp-file= code *fails* on emacs version 25.1.1 (but works on 26.1).

*** creating PID file
Before launching emacs server in my [[file:.login][~/.login]] file, I check PID file created by
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs :shebang ";; -*-  lexical-binding: t; -*-"
;;
;; see https://github.com/chalaev/lisp-goodies/blob/master/packaged/start.el
(load-file "/path-to/start.el")

;; creating PID file for emacs; useful when it gets started from ~/.login
;; see https://github.com/chalaev/lisp-goodies/blob/master/.login
(make-temp-file "emacs-" nil ".pid" (format "%d
" (emacs-pid))); requires version(emacs) > 26
#+END_SRC

*** placing/finding local packages
The following 3 blocks allow me to require simple (consisting of one file) locally created packages, for example, this one – =(require 'shalaev)=;

Defining important directories:
#+BEGIN_SRC emacs-lisp :tangle generated/local-packages.el
(defvar ~ (file-name-as-directory (getenv "HOME")))
(defun tilde(x &optional HOME)
(let((H(or HOME ~)))
#+END_SRC
← in emacs-lisp we can not =(let((HOME(or HOME ~)))...)=; local variable name has to be different
#+BEGIN_SRC emacs-lisp :tangle generated/local-packages.el
 (replace-regexp-in-string (concat "^" H) "~/" x)))
(defun untilde(x &optional home-dir)
 (replace-regexp-in-string "^~/" 
   (or home-dir ~); do not use =file-name-as-directory= here as =home-dir= might be an *arbitrary* string (expression)
 x))
(defvar *emacs-d* (concat "~/" (file-name-as-directory ".emacs.d")))
#+END_SRC

Inform ~emacs~ about new directory =~/.emacs.d/local-packages/= containing package files
(and create it if necessary):
#+BEGIN_SRC emacs-lisp :tangle generated/local-packages.el
(require 'package)
(unless (assoc "local-packages" package-archives)
  (push (cons  "local-packages" (concat *emacs-d* (file-name-as-directory "local-packages")))
	package-archives))
(make-directory (cdr (assoc "local-packages" package-archives)) t)
#+END_SRC

Adjusting [[https://www.emacswiki.org/emacs/LoadPath][load-path]]:
#+BEGIN_SRC emacs-lisp :tangle generated/local-packages.el
(unless(member(cdr(assoc "local-packages" package-archives)) load-path)
  (add-to-list 'load-path (cdr(assoc "local-packages" package-archives))))
#+END_SRC

*** for using in Makefiles
My [[https://github.com/chalaev/backup2l.conf][backup]] system does not save files having the group ~tmp~.
I use this group to mark all generated (tangled) files:
#+BEGIN_SRC emacs-lisp :tangle generated/make.el :shebang ";; -*-  lexical-binding: t; -*-"
(require 'shalaev) ; ← needed for perms-from-str unless you have loaded it in another way
(defun after-tangle()
  "mark tangled files as non-backupable (chgrp tmp files) and non-excecutable"
  (let ((FN (buffer-file-name)))
#+END_SRC
The following line is equivalent to =chmod a-x FN=:
#+BEGIN_SRC emacs-lisp :tangle generated/make.el
    (set-file-modes FN (logand #o666 (perms-from-str (nth 8 (file-attributes FN 'string)))))
    (chgrp "tmp" FN)))
(add-hook 'org-babel-post-tangle-hook #'after-tangle)
#+END_SRC
so they are not backuped.
(Another way to set tangled files' permission is by [[https://orgmode.org/manual/Extracting-Source-Code.html#Header-arguments][updating]] the corresponding =BEGIN_SRC= line.)

My literate programming relies on emacs org mode and its =M-x org-babel-tangle= command, which I want to output the names of the generated files.
So in [[file:Makefile][Makefiles]] I often use ~printangle~ [it returns the list of exported (tangled) files]:
#+BEGIN_SRC emacs-lisp :tangle generated/make.el
;;(require 'org-babel)
(defun printangle(FN)
  "to be used in Makefile instead of org-babel-tangle-file"
  (let ((l (length default-directory)))
    (apply #'concat (mapcar #'(lambda(x) (substring (format "%s " x) l)) (org-babel-tangle-file FN)))))
#+END_SRC
← my [[https://github.com/chalaev/cl-simple-logger/blob/master/Makefile][Makefile]]s load its definition from [[file:helpers/derive-version.el][derive-version.el]].

*** Auto-updating certain blocks on save
Sometimes part of the code is automatically generated by emacs (e.g., from a table).
The following block regenerates such pieces of code before every save:
#+BEGIN_SRC emacs-lisp :tangle generated/make.el
(defvar eval-on-save nil "list of block names to be updated")
(defun eval-on-save (&rest var-names)
(let((BN(buffer-name)))
(when(and
(string= "org" (file-name-extension BN))
(not(member BN (mapcar #'car eval-on-save))))
(push(cons BN var-names) eval-on-save))))

(add-hook 'before-save-hook
(lambda()(save-excursion(let((BN(buffer-name)))
 (dolist(ES eval-on-save)
(when(string= BN (car ES)) ;; (clog :debug "'before-save-hook doing nothing cause %s is not an .org buffer" BN)
(clog :debug "activating before-save-hook for %s" BN)
 (dolist(block-name (cdr ES))
  (if(org-babel-goto-named-src-block block-name) (clog :error "could not find %s in %s" block-name BN)
    (org-babel-execute-src-block)))))))))
#+END_SRC
← provided that corresponding block names are contained in the =eval-on-save= variable, see [[https://github.com/chalaev/cloud/blob/master/cloud.org][cloud.org]] for an example.

=push-new= is used in my =cloud= project:
#+BEGIN_SRC emacs-lisp :tangle generated/make.el
(defmacro push-new(where &rest what)
  "allows many arguments"
`(progn ,@(mapcar #'(lambda(w) `(cl-pushnew ,w ,where :test #'string=)) what)))
#+END_SRC

*** Other stuff
(found online) =run-init-block=  runs ~init~ code block when loading an org-file:
#+BEGIN_SRC emacs-lisp :tangle generated/make.el
(defun run-init-block ()
"runs code block labeled 'init' when an org-file is opened in emacs"
  (org-babel-goto-named-src-block "init")
  (org-babel-execute-src-block))
#+END_SRC

** replacing cl-lib.el
This section will probably be archived because
=cl-lib= is used by so many packages so it is probably impossible to avoid it.

*** s-gensym
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el :shebang ";; -*-  lexical-binding: t; -*-"
(let ((counter 0))
  (defun s-gensym(&optional starts-with)
    "similar to gensym in Common Lisp"
    (unless starts-with (setf starts-with "gs"))
    (let(sym)
      (while (progn
               (setf sym (make-symbol (concat starts-with (number-to-string counter))))
               (or (special-form-p sym) (functionp sym) (macrop sym) (boundp sym)))
        (s-incf counter))
      (s-incf counter)
      sym)))
#+END_SRC
=s-gensym= is used in macros, e.g.
#+BEGIN_SRC emacs-lisp :results drawer
(let ((ms (s-gensym "a")))
  `(let ((,ms 0))
     (1+ ,ms)))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((a3 0)) (1+ a3))
:END:

*** s-find
~s-find~ stands for "shalaev-find"; note that it is *not* compatible with ~find~ from ~cl.el~:
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(defun s-find(item seq &optional key test)
  (let ((CS(car seq)) found (test (or test 
(cond
  ((stringp item) #'string=)
  ((numberp item) #'=)
  (t #'eq)))))
  (while
     (and
       (not (setf found (funcall test item (if key (funcall key CS) CS))))
       (setf seq (cdr seq)))
     (setf CS(car seq)))
     (when found CS)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest s-find.1()
  (should (equal '(3 4) (s-find 4 '((1 2) (3 4) (5 6)) #'cadr)))
  (should (= 3 (s-find 3 '(1 2 3 4 5))))
(let ((cumbersome-list '(141 142 143 144)))
  (should (= (s-find (* 12 12) cumbersome-list nil #'=) 144))
  (should (= (s-find (/ 144 2) cumbersome-list nil #'(lambda(x y) (= (* 2 x) y))) 144))
  (should (= (s-find 12 cumbersome-list nil #'(lambda(x y) (= (* x x) y))) 144)))
(let ((cumbersome-list '((141 142) (143 144))))
  (should (equal (s-find 12 cumbersome-list #'cadr #'(lambda(x y) (= y (* x x)))) '(143 144)))))
(ert-deftest s-find.2()
"this code comes from cloud project"
(let((plain(lambda(FR)(aref FR 0))) (cipher(lambda(FR)(aref FR 6)))
    (file-DB(list
  ["/home/user/proj/chat/chat.org" "shalaev" "shalaev" (24559 50916 0 0) 48756 420 "U3j"]
  ["~/proj/lisp-goodies/shalaev.org" "shalaev" "shalaev" (24552 57834 0 0) 432 61533 "Q8T"])))
(should(string= "/home/user/proj/chat/chat.org"   (funcall plain (s-find "U3j" file-DB cipher #'string=))))
(should(string= "~/proj/lisp-goodies/shalaev.org" (funcall plain (s-find "Q8T" file-DB cipher #'string=))))))
#+END_SRC

Note the difference from ~find~ defined in ~cl.el~: instead of
#+BEGIN_SRC emacs-lisp
(let ((cumbersome-list '((141 142) (143 144) (145 146))))
  (find 12 cumbersome-list :key #'cadr :test #'(lambda(x y) (= y (* x x)))))
#+END_SRC
we write
#+BEGIN_SRC emacs-lisp
(let ((cumbersome-list '((141 142) (143 144) (145 146))))
  (s-find 12 cumbersome-list #'cadr #'(lambda(x y) (= y (* x x)))))
#+END_SRC

*** s-decf and s-incf
#+BEGIN_SRC emacs-lisp
(defmacro s-decf (var &optional amount)
  (unless amount (setf amount 1))
  `(setf ,var (- ,var ,amount)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(defmacro s-incf (var &optional amount)
  (unless amount (setf amount 1))
  `(setf ,var (+ ,var ,amount)))
#+END_SRC

*** lett (replacing flet + let)
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(defmacro lett(var-defs &rest body)
"let where one can define (usual) local variables as well as local functions"
  (if(car var-defs)
      (let((ME (macroexpand-1 `(lett ,(cdr var-defs) ,@body))))
      (if(and(listp (car var-defs))(eql 'defun (caar var-defs)))
	  (let((func-data (cdar var-defs)))
	    `(let((,(car func-data) (lambda ,(cadr func-data) ,@(cddr func-data))))
	        ,ME))
	`(let(,(car var-defs)) ,ME)))
    `(progn ,@body)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest lett()
(should(eval(let((fName(s-gensym)))
`(lett(z (a 2) (defun ,fName(x)(1+ x)) w)
 (functionp ,fName)))))

(should(not(let((fName(s-gensym)))
(functionp fName))))

(let((fName(s-gensym)))
(should(not(or (special-form-p fName) (functionp fName) (macrop fName) (boundp fName)))))

(should (= 6 (lett(z (a 2) (defun sw(x)(1+ x)) w)
  (unless (or z w)
    (setf z (funcall sw a))
    (* z a))))))
#+END_SRC

Warning: one has to use =funcall= with the functions defined in the =lett= header, e.g.
#+BEGIN_SRC emacs-lisp
(lett(z (a 2) (defun mf(x)(1+ x)))
     (setf z (funcall mf a))
     z)
#+END_SRC

#+RESULTS:
: 3

*** select, without, and drop
#+BEGIN_SRC emacs-lisp :tangle generated/local-packages.el
(defun select (from-where match-test)
  "select items matching the test"
    (let (collected wasted)
       (dolist (list-item from-where)
	 (if (funcall match-test list-item)
	   (push list-item collected)
	   (push list-item wasted)))
(cons (reverse collected) (reverse wasted))))
(defun CPU-cores()
  "return number of CPU cores in linux"
  (length(car(select(process-lines "cat" "/proc/cpuinfo")
      (lambda(str) (string-match "processor[[:blank:]]+:[[:blank:]]+[[:digit:]]+$" str))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest select()
(let ((test-list  '(4 22 11 33 12 24 77)))
  (should (not (car (select test-list #'zerop))))
  (should (equal '(11 33 77) (car (select test-list #'cl-oddp))))
  (should (equal '(4 22 12 24) (car (select test-list #'cl-evenp))))))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/files.lisp
(defun without(source wrong-items &key (key #'identity) (test #'eql))
  "returns (copy of) source without wrong-items"
  (let((WI(if(listp wrong-items) wrong-items (list wrong-items))))
    (remove-if #'(lambda(x) (find (funcall key x) WI :test test)) source)))
(define-modify-macro drop(place &rest what) without)
#+END_SRC

#+RESULTS:
: DROP

#+BEGIN_SRC lisp :results drawer
(macroexpand `(drop ll 2 4))
#+END_SRC

#+RESULTS:
:RESULTS:
(SETQ LL (WITHOUT LL 2 4))
T
:END:

#+BEGIN_SRC lisp
(define-modify-macro filter-list (ll fun)
  (lambda(ll fun) (remove-if-not fun ll)))
#+END_SRC

#+RESULTS:
: FILTER-LIST

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest without.1
(let((ll '(1 2 3 4)))
  (without ll 2))
(1 3 4))
(deftest drop.1
(let((ll '(1 2 3 4)))
  (drop ll '(2 4))
  ll)
(1 3))
(deftest without.2
(let((ll '((1 2) (3 4 5) (6 7 8 9))))
  (without ll '(2 3 7) :key #'cadr))
((3 4 5)))
(deftest drop.2
(let((ll '((1 2) (3 4 5) (6 7 8 9))))
  (drop ll '(2 3 7) :key #'cadr)
ll)
((3 4 5)))
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle generated/functions.el :shebang ";; -*-  lexical-binding: t; -*-"
(defun without(source &rest wrong-items)
  "returns (copy of) source without wrong-items"
  (car (select source #'(lambda(x) (not (member x wrong-items))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest without()
(let ((test-list  '(4 22 11 33 12 24 77)))
  (should (equal '(4 22 11 33 77) (without test-list 12 24)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro drop (from-where &rest what)
`(setf ,from-where (without ,from-where ,@what)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest drop()
(let ((test-list  '(4 22 11 33 12 24 77)))
  (drop test-list 12 24)
  (should (equal '(4 22 11 33 77) test-list))))
#+END_SRC

*** to do
reduce, …

** short pieces of code
*** case*
~case*~ is not identical to =case= from =cl.el=:
it uses arbitrary test function:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro case* (expr test &rest cases)
  "case with arbitrary test function"
  (let ((v (s-gensym "v")))
    `(let ((,v ,expr))
       (cond
        ,@(mapcar #'(lambda (VR)
(let ((val (car VR)) (rest (cdr VR)))
  (if (eql val 'otherwise)
      `(t ,@rest)
    `((,test ,v ,val) ,@rest))))
 cases)))))
#+END_SRC
A simple example:
#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1 
 `(case* (+ 1 2) =
    (choice-1 (message "choice-1"))
    (choice-2 (message "choice-2"))
    (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((v13 (+ 1 2)))
 (cond 
((= v13 choice-1) (message choice-1))
((= v13 choice-2) (message choice-2))
(t (message no match))))
:END:

Another example is also self-explanatory:
#+BEGIN_SRC emacs-lisp :results drawer
(let ((x 32) (choice-1 22)  (choice-2 33))
  (case* (1+ x) =
    (choice-1 (message "choice-1"))
    (choice-2 (message "choice-2"))
    (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
choice-2
:END:

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro case* (expr test &rest cases)
  "case with arbitrary test function"
  (let ((v (gensym "v")))
    `(let ((,v ,expr))
       (cond
        ,@(mapcar #'(lambda (VR)
(let ((val (car VR)) (rest (cdr VR)))
  (if (eql val 'otherwise)
      `(t ,@rest)
    `((,test ,v ,val) ,@rest))))
 cases)))))
#+END_SRC

#+BEGIN_SRC lisp :results drawer
(let((str "by"))
  (shalaev:case* str string=
		 ("hello" 1)
		 ("by" 2)
		 (otherwise 3)))
#+END_SRC

*** case-expand
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro case-expand (input (&key (test #'char=)) &body cases)
  "same as case, allows macros as entries (marked with keyword expand)"
  (let ((block-sym (gensym "block")))
    `(block ,block-sym
       ,@(loop for (value . body) in cases
	    if (eql value 'otherwise)
	    collect `(return-from ,block-sym (progn ,@body))
	    else if (eql value 'expand)
	    collect
	      (destructuring-bind (args . code) (macroexpand-1 body)
		`(when ,args
		   (return-from ,block-sym (progn ,@code))))
	    else
	    collect `(when (funcall ,test ,input ,value)
		       (return-from ,block-sym (progn ,@body)))))))
#+END_SRC

Example:
#+BEGIN_SRC lisp
(let((x "rechts"))
(case-expand x (:test #'string=)
  ("links" "left")
  ("rechts" "right")
  (otherwise "center")))
#+END_SRC

*** case-f
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro case-f (input-function r &body cases)
  "Same as case-expand, but the first arg is function applied to each case,
and the variable r contains the result of such application."
  (let((block-sym (gensym "block")))
    `(block ,block-sym
       ,@(loop for (value . body) in cases
	    if (eql value 'otherwise)
	    collect `(return-from ,block-sym (progn ,@body))
	    else if (eql value 'expand)
	    collect
	      (destructuring-bind (args . code) (macroexpand-1 body)
		`(when ,(if (consp args); ← might be a list or one value
			    `(apply ,input-function ,args)
			    `(funcall ,input-function ,args))
		   (return-from ,block-sym (progn ,@code))))
	    else
	    collect
	      `(let(,r)
		 (setf ,r (funcall ,input-function ,value))
		 (when ,r (return-from ,block-sym (progn ,@body))))))))
#+END_SRC

*** case-let
=case-let= is probably *useless*:
as of 2020-11-04 I think that small convenience due to slight code size reduction does not compensate new symbol introduction, so =case-let= remains unused for now.

Sometimes we may want to access the let-variable name generated in =case*=;
so we define =case-let= which is only a slightly modified version of =case*=:
#+BEGIN_SRC emacs-lisp
(defmacro case-let (let-var expr test &rest cases)
  "case* with let expriable named by the user"
    `(let ((,let-var ,expr))
       (cond
        ,@(mapcar #'(lambda (VR)
(let ((val (car VR)) (rest (cdr VR)))
  (if (eql val 'otherwise)
      `(t ,@rest)
    `((,test ,let-var ,val) ,@rest))))
 cases))))
#+END_SRC
A simple example:
#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1 
 `(case-let x (+ 1 2) =
    (choice-1 (format "1: x=%d" x))
    (choice-1 (format "2: x=%d" x))
    (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((x (+ 1 2))) (cond ((= x choice-1) (format 1: x=%d x)) ((= x choice-1) (format 2: x=%d x)) (t (message no match))))
:END:

*** when-set and unless-set
Sometimes instead of =when-let= I use somewhat similar =when-set= macro.
=when-set= is similar to =when-let= except for that it uses existing global variables instead of creating local ones.

#+begin_note
Global variable values will *not* be set to ~nil~.
#+end_note

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro when-set (vars &rest body)
  "when-let using global variable instead of defining local one"
(let ((GV (s-gensym)))
  `(let ((,GV ,(cadar vars)))
     ,(if (cdr vars)
	  `(when ,GV
              (setf ,(caar vars) ,GV)
	     ,(macroexpand-1 `(when-set ,(cdr vars) ,@body)))
	(append `(when ,GV (setf ,(caar vars) ,GV)) body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1
 `(when-set ((CN (clouded (aref newDBrec cipher))) (NFE (not (file-exists-p CN))))
    (+ 1 2)
    (- 1 2)))
#+END_SRC

#+RESULTS:
:RESULTS:
(let((gs4 (clouded (aref newDBrec cipher))))
  (when gs4
    (setf CN gs4)
    (let((gs5 (not (file-exists-p CN))))
      (when gs5
	(setf NFE gs5)
	(+ 1 2) (- 1 2)))))
:END:

=unless-set= is similar to =when-set=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro unless-set (vars &rest body)
  "unless-let using global variable instead of defining local one"
(let ((GV (s-gensym)))
  `(let ((,GV ,(cadar vars)))
     ,(if (cdr vars)
	  `(if ,GV
              (setf ,(caar vars) ,GV)
	     ,(macroexpand-1 `(unless-set ,(cdr vars) ,@body)))
	(append `(if ,GV (setf ,(caar vars) ,GV)) body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
 `(unless-set ((CN (aref newDBrec cipher)) (FE (file-exists-p CN)))
    (+ 1 2)
    (- 1 2))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((g30 (aref newDBrec cipher)))
  (if g30
     (setf CN g30) 
(let ((g31 (file-exists-p CN)))
    (if g31 (setf FE g31)
       (+ 1 2)
       (- 1 2)))))
:END:

*** if-set
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro if-set (vars &rest body)
  (let((if-true (s-gensym "it")) (result (s-gensym "r")))
    `(let(,if-true ,result)
       (setf ,result (when-set ,vars
		  (setf ,if-true t)
		  ,(car body)))
       (if ,if-true ,result
	 ,@(cdr body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1
  '(if-set ((x 1) (y (1+ x)))
     (+ x y) (- x y) (* x y)))
#+END_SRC

#+RESULTS:
:RESULTS:
(let(it2 r3)
  (setf r3 (when-set((x 1) (y (1+ x))) (setf it2 t) (+ x y)))
  (if it2 r3 (- x y) (* x y)))
:END:

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn-set (vars ifno &rest body)
`(if-set ,vars
   (progn ,@body)
   ,ifno))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 (macroexpand-1 
'(ifn-set
  ((remote/files (cdr (assoc "remote/files" conf)))
   (N-CPU-cores (string-to-number (or (cdr (assoc "number-of-CPU-cores" conf)) "1")))
   (password  (cdr (assoc "password" conf)))
   (remote-dir (cdr (assoc "remote-directory" conf))))
(clog :error "something is missing or wrong in the configuration file" remote-dir)
(print "everything is ok")
(print "so we proceed")))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let (it32 r33) 
  (setf r33
	(when-set ((remote/files (cdr (assoc remote/files conf)))
		   (N-CPU-cores (string-to-number (or (cdr (assoc number-of-CPU-cores conf)) 1)))
		   (password (cdr (assoc password conf)))
		   (remote-dir (cdr (assoc remote-directory conf))))
		  (setf it32 t)
		  (progn (print everything is ok) (print so we proceed))))
  (if it32
      r33
    (clog :error something is missing or wrong in the configuration file remote-dir)))
:END:

*** cond-let
=cond-let= is a natural generalization of =if-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro cond-let (&rest conds)
  "cond with let"
  (let ((c (car conds)) (r (cdr conds)))
    (if (equal (car c) 'otherwise) `(progn ,@(cdr c))
    (if r
	`(if-let ,(car c) (progn ,@(cdr c)) ,(macroexpand-1 `(cond-let ,@r)))
	`(when-let ,(car c) ,@(cdr c))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
  '(cond-let
    (((x 1) (y (1+ x))) (+ x y) (- x y) (* x y))
    (((x 3) (y (1+ x))) (+ x y) (- x y) (/ x y))
    (otherwise 22 33))))
#+END_SRC

#+RESULTS:
:RESULTS:
(if-let ((x 1) (y (1+ x)))
 (progn (+ x y) (- x y) (* x y)) 
(if-let ((x 3) (y (1+ x)))
 (progn (+ x y) (- x y) (/ x y))
 (progn 22 33)))
:END:

Formatted result:
#+BEGIN_SRC emacs-lisp
(if-let ((x 1) (y (1+ x)))
  (progn (+ x y) (- x y) (* x y))
  (if-let ((x 3) (y (1+ x))) 
    (progn (+ x y) (- x y) (/ x y))
    (progn 22 33)))
#+END_SRC

Common Lisp version is the same as elisp one:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.lisp
(defmacro cond-let(&rest conds)
  "cond with let"
  (let ((c (car conds)) (r (cdr conds)))
    (if (equal (car c) 'otherwise) `(progn ,@(cdr c))
    (if r
	`(if-let ,(car c) (progn ,@(cdr c)) ,(macroexpand-1 `(cond-let ,@r)))
	`(when-let ,(car c) ,@(cdr c))))))
#+END_SRC

*** error-in
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro error-in(where &rest body)
"handles unrecognized errors"
`(condition-case err (progn ,@body)
   (error(clog :error (concat "error in " ,where " because
%s") (error-message-string err)))))
#+END_SRC
← to be placed in interactive functions.

Example:
#+BEGIN_SRC emacs-lisp
(error-in "my function" (delete-file "/tmp") t)
#+END_SRC
logs an error message:
:error 13:34:43 error in my function because
Removing old name: is a directory: /tmp

*** email
A non-interactive =email= function:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun email (addr &optional subject body)
  "fast non-interactive way to send an email"
  (compose-mail addr (if subject subject ""))
  (when body (insert body))
  (message-send-and-exit))
#+END_SRC
– will work if mailing system (~exim4~ in my case) is configured properly.

*** pos
Position of an element in a list:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun pos (el ll)
  (let ((i 0) r)
  (dolist (e ll r)
    (if (eql e el)
	(setf r i)
      (s-incf i)))))
#+END_SRC

*** perms-from-str
When I ask ~emacs~ to show me file's permissions, it provides a text string (e.g., "-rw-rw----") instead of a number.
The following function produces a number from such a string:
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el :shebang ";; -*-  lexical-binding: t; -*-"
(require 'cl-lib); hopefully one day I will remove this line
(defun perms-from-str (str)
"parses file mode string into integer"
  (let ((text-mode (reverse (cdr (append str nil)))) (mode 0) (fac 1))
    (cl-loop for c in text-mode for i from 0
          unless (= c ?-) do (s-incf mode fac)
          do (setf fac (* 2 fac)))
    mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest perms-from-str()
  (should (= 432 (perms-from-str "-rw-rw----"))))
#+END_SRC

*** perms-to-str
=perms-to-str= is just the opposite of [[perms-from-str]].

#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun perms-to-str(file-mode)
"formats integer file mode into string"
(let ((ll '((1 . 0))))
  (apply #'concat (mapcar
		   #'(lambda(x) (format "%c" (if (= 0 (logand file-mode (car x))) ?- (aref "xwr" (cdr x)))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest perms-to-str()
  (should (string= "rw-rw-rwx" (perms-to-str #o667))))
#+END_SRC

*** time<
In =time<= I have to add 3 seconds of time to avoid chatter effects:
if at some moment the files are synchronized between the host and the cloud,
this situation might change due to time-desynchronization.
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun time< (t1 t2)
  (and
    (time-less-p (time-add t1 3) t2)
    (not (time-less-p (time-add t2 3) t1))))
#+END_SRC
This problem demonstrates the importance of the time synchronization (via =ntpdate= or an =ntp= server).

*** parsing time and date
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-date (str)
  (mapcar 'string-to-number
	  (cond
 ((string-match "\\([0-9]\\{4\\}\\)[/-]\\([0-9][0-9]\\)[/-]\\([0-9][0-9]\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(3 2 1)))
 ((string-match "\\([0-9][0-9]\\)[/-]\\([0-9][0-9]\\)[/-]\\([0-9]\\{4\\}\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(2 1 3)))
 ((string-match "\\([0-9][0-9]\\)\\.\\([0-9][0-9]\\)\\.\\([0-9]\\{4\\}\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(1 2 3)))
 ((string-match "\\([0-9][0-9]\\)/\\([0-9][0-9]\\)/\\([0-9]\\{2\\}\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(2 1 3)))
 ((string-match "\\([0-9]\\{2\\}\\)[/-]\\([0-9][0-9]\\)" str) (append (mapcar #'(lambda (x) (match-string x str)) '(2 1)) (list (format-time-string "%Y" (current-time)))))
 (t (clog :error "date format not recognized in %s" str) nil))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-only-time (str)
  (firstN (parse-time-string str) 3))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-date-time(str)
  (if (string-match "[0-9]\\{4\\}-[0-9][0-9]-[0-9][0-9] [0-9][0-9]:[0-9][0-9]" str)
      (parse-time-string str)
    (let ((SS (split-string str)))
      (append (parse-only-time (cadr SS))
	      (parse-date (car SS))))))
#+END_SRC
Example:
#+BEGIN_SRC emacs-lisp :results drawer
(cons (parse-only-time "16:09:37")
(mapcar #'(lambda(x) (format-time-string "%F %H:%M:%S %Z" (apply #'encode-time (parse-date-time x))))
 (list "10/21 14:54"
        "2020-10-10 14:54:40  EDT")))
#+END_SRC

#+RESULTS:
:RESULTS:
((37 9 16) 2020-10-21 14:54:00 EDT 2020-10-10 14:54:40 EDT)
:END:

* configuration files
Instead of storing configuration in =.el= files (e.g., =~/.emacs=), I prefer to store it in a separate file.
This is because
1. sometimes the code will update its configuration, and
2. in this way configuration data is more separated from other ~elisp~ programs.

** read-conf-file
#+BEGIN_SRC emacs-lisp :tangle generated/conf.el :shebang ";; -*-  lexical-binding: t; -*-"
(defmacro while-let(var-defs while-cond &rest body)
  `(let* (,@var-defs)
     (while ,while-cond
       ,@body)))
#+END_SRC

Note: only Latin characters are allowed in config files
#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(defun read-conf-file(FN &optional max-size)
  "reads configuration file"
  (error-in "read-conf-file"
(with-temp-buffer(insert-file-contents (untilde FN))
(setf buffer-read-only t)
(let(res)					      
  (dolist(str(split-string (buffer-string) "\n"))
    ;; (clog :debug "str= %s" str)
	    (unless(or
(string= "
" str)
(= ?# (string-to-char str))); ignoring comments or empty lines
(if(string-match "^\\(\\ca+\\)=\\([[:print:]]+\\)$" str)
	  (let((key(intern(match-string 1 str))) (val(match-string 2 str)))
	    (if(assoc key res)
		(setcdr (assoc key res) val)
	      (push (cons key val) res)))
(unless(string= "" str)
	(clog :warning "invalid string in %s: %s" FN str)))))
(reverse res)))))
#+END_SRC

Minimal Common Lisp configuration file reader (only for strings and integers):
#+BEGIN_SRC lisp :tangle generated/conf.lisp
(defun read-conf-file(FN)
  "reads configuration file"
(when(probe-file FN) (delete nil
(with-open-file (in FN)
    (loop for str = (read-line in nil nil) while str
	with matches collect
(case-f (lambda(regexp) (nth-value 1 (cl-ppcre:scan-to-strings regexp str))) matches; for now we scan for integer numbers only
("^(\\p{Script:Latin}+)\\s*=\\s*(\\d+)\\s*$" ; does not allow numbers in the property name
  (cons (aref matches 0) (parse-integer(aref matches 1))))
("^(\\p{Script:Latin}+)\\s*=\\s*([^\\s]+)\\s*$"
  (cons (aref matches 0) (aref matches 1)))
(otherwise (warn "unrecognized line: ~s" str))))))))
#+END_SRC
← I am creating special package for that because of extra dependences
=:cl-ppcre= and =:cl-ppcre-unicode=

08/02 Let me save in the same file functions for encoding and decoding numbers to/from strings:
#+BEGIN_SRC lisp :tangle generated/conf.lisp
(let((all-chars "0123456789abcdefghijklmnopqrstuvwxyz") (EC "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
(defun rand-str(&optional (N 8) (extraChars EC))
"random string of N characters"
(declare (type integer N) (type string extraChars))
(let((AC(concatenate 'string all-chars extraChars)))
  (apply #'concatenate (cons 'string
    (loop repeat N collect (string (elt AC (random (length AC)))))))))
(defun intToChar(intNumer &optional (extraChars EC))
"encodes integer into string"
(declare (type integer intNumer) (type string extraChars))
(let*((AC(concatenate 'string all-chars extraChars))
      (lad(length AC)) divmod)
(declare (type integer lad))
    (loop do
	 (setf divmod (multiple-value-call #'list (floor intNumer lad))
	       intNumer (car divmod))
       collecting (char AC (cadr divmod)) into res
       while (> intNumer 0)
       finally (return (concatenate 'string (reverse res))))))
(defun charToInt(str &optional (extraChars EC))
"decodes string encoded by intToChar"
(declare (type string str extraChars))
(let*((AC(concatenate 'string all-chars extraChars))
      (lad(length AC)) (res 0) (base 1))
(declare (type integer lad res base))
	(dolist (c (concatenate 'list (reverse str)))
	  (incf res (* base (position c AC)))
	  (setf base (* base lad)))
	res)))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest intToChar
(charToInt(intToChar 123456789))
123456789)
#+END_SRC

** parse-conf
#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(defun parse-parameter(str &optional par-type)
"for =parse-conf=: optionally parses first (string) argument into the specified type"
  (when str
    (cond
     ((eql par-type 'integer) (string-to-number str))
#+END_SRC
← =integer= is the only recognized type as of 02/23; we might need more special type treatment here.
#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
     ((consp par-type) (mapcar #'(lambda(s)(parse-parameter s (car par-type))) (split-string str)))
     (t str))))
#+END_SRC
← e.g., =(parse-parameter "a b f qwfe weq" '(string))= ⇒ =("a" "b" "f" "qwfe" "weq")=.

#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(defun typeof(v)
"when v is a keyword, returns corresp. symbol; otherwise returns v's type"
  (if(consp v) (if(eql(car v) 'quote) (typeof(cadr v))  (list(typeof(car v))))
    (cond
     ((keywordp v) (intern(substring(symbol-name v)1)))
     (t(type-of v)))))
#+END_SRC
← e.g., =(typeof '("1" "2"))= ⇒ =(string)=, and =(typeof :integer)= ⇒ =integer=.

#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(defun KP(x)(if(listp x)(KP(car x))(keywordp x)))
(defun typeof-expr(expr)
  (cond
   ((listp expr) (when-let((TO(typeof-expr(car expr)))) (list TO)))
   ((consp expr) nil)
   (t (let((TO(typeof expr)))
	(unless(eql TO 'symbol) TO)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest typeof-expr()
(should(eql 'integer (typeof-expr 1)))
(should(equal '(integer) (typeof-expr '(1 2))))
(should(eql 'string (typeof-expr "abc")))
(should(equal '(string) (typeof-expr '("abc" "def"))))
(should(not(typeof-expr '(incf z)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(defmacro parse-conf(conf-expr vars)
"for =let-conf=: produces configuration (list of conses) updates variables =vars= conf-expr"
  (let((conf(s-gensym "conf")))
    `(let((,conf ,conf-expr))
(list ,@(mapcar
    #'(lambda(CV)
	(if(listp CV)
	    (if(cddr CV)
#+END_SRC
if =(length CV)= ⇒ 3:
#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(let((TO(typeof(car CV))))
  `(cons (quote ,(cadr CV))
	 ,(if-let((cCV(caddr CV)))
	      `(or(parse-parameter(cdr(assoc (quote ,(cadr CV)) ,conf)) (quote ,TO)) ,cCV)
	    `(parse-parameter(cdr(assoc (quote ,(cadr CV)) ,conf)) (quote ,TO)))))
#+END_SRC
if =(length CV)= ⇒ 2, type =TO= is either specified explicitly (when =(KP(car CV))= ⇒ t), or is determined from the default value:
#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(let((TO(typeof-expr(car(if(KP(car CV)) CV (cdr CV)))))
     (varName(if(KP(car CV)) (cadr CV) (car CV)))
     (default(unless(KP(car CV))(cadr CV))))
  `(cons (quote ,varName)
	 ,(if default
	      `(or(parse-parameter(cdr(assoc (quote ,varName) ,conf)) (quote ,TO)) ,default)
	    `(parse-parameter(cdr(assoc (quote ,varName) ,conf)) (quote ,TO))))))
#+END_SRC
if =(listp CV)= ⇒ nil:
#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
`(cons (quote ,CV) (parse-parameter(cdr(assoc (quote ,CV) ,conf))))))
	 vars)))))
#+END_SRC
Usage examples:
1. simplest case: =(parse-conf cc (a b))= ⇒ (expands to)
   =(let((conf14 cc))=
     =(list (cons (quote a) (parse-parameter (cdr (assoc (quote a) conf14))))=
           =(cons (quote b) (parse-parameter (cdr (assoc (quote b) conf14))))))=
2. specifying value type =(parse-conf cc ((:integer a) ((:integer) b)))= is useful when no default value supplied ⇒
   =(let((conf17 cc))=
     =(list=
      =(cons (quote a) (parse-parameter (cdr (assoc (quote a) conf17)) (quote integer)))=
      =(cons (quote b) (parse-parameter (cdr (assoc (quote b) conf17)) (quote (integer))))))=
3. specifying default values (used unless contained in =cc=): =(parse-conf cc ((a 1) (c 3)))=  ⇒
   allows to supply type to =parse-parameter=:
   =(let((conf20 cc))=
     =(list=
      =(cons (quote a) (or (parse-parameter (cdr (assoc (quote a) conf20)) (quote integer)) 1))=
      =(cons (quote c) (or (parse-parameter (cdr (assoc (quote c) conf20)) (quote integer)) 3))))=
4. sometimes, when default value is a variable, both type and default value must be specified:
   =(parse-conf cc ((:integer abc xy)))= ⇒
   =(let((conf21 cc))=
      =(list=
       =(cons (quote abc) (or (parse-parameter (cdr (assoc (quote abc) conf21)) (quote integer)) xy))))=

** let-conf
=let-conf= declares local variables in the usual =let= manner with optional default values (see [[parse-conf]] examples above).
The values are updated from configuration (list of conses) produced by ~conf-expr~ form.
#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(defmacro let-conf(configuration vars &rest body)
  `(let((,(car configuration) (parse-conf ,(cdr configuration) ,vars)))
,@body))
#+END_SRC
where only the configuration parameters mentioned in =vars= argument will be considered.

#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(defmacro let-conf-c(CName variable-name)
"for let-conf"
 `(cdr(assoc(quote ,variable-name) ,CName)))
#+END_SRC
←  I would probably use =macrolet= inside =letc= for =let-conf-c= but prefer to avoid using =cl.el=.

Usage example (see, e.g., [[https://github.com/chalaev/el-backup/blob/master/backup.org][el-backup project]]):
#+BEGIN_SRC emacs-lisp :results drawer
(let-conf(conf . (read-conf-file (concat *config-directory* "el-backup.conf")))
  ((black-groups ("tmp")))
  (let-conf-c black-groups))
#+END_SRC

#+RESULTS:
:RESULTS:
(tmp)
:END:

In case we want to define variables locally:
#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(defmacro letc(conf-data vars &rest body)
(let((conf-var(s-gensym)))
  `(let((,conf-var (parse-conf ,conf-data ,vars)))
(let(,@(mapcar (lambda(v)
(let((VN(ifn(listp v)v(if(KP(car v))(cadr v)(car v)))))
`(,VN (let-conf-c ,conf-var ,VN))))
vars))
,@body))))
#+END_SRC

Sometimes for testing we need to change local variables in the least possible intrusive way.
We do it as follows: main code contains a specially marked comment like this one:
#+BEGIN_SRC emacs-lisp
;;test>;; (some-code)
#+END_SRC
← [[file:Makefile][Makefile]] will remove these lines from the [[file:packaged/cloud.el][packaged code]], and uncomment them in the [[file:tests/cloud.el][testing version]].


#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(defmacro setc(FN vars &rest body)
`(letc(read-conf-file ,FN) ,vars ,@body))
#+END_SRC

** write-conf
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun together(strings)
"concatenates list of strings"
(if strings
  (mapconcat 'identity strings " ")
  ""))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(defun print-variable(var)
(cond
((stringp var) var)
((integerp var) (format "%d" var))
((listp var) (together(mapcar #'print-variable var)))
(t
(clog :error "type of %s is undefined" var)
 "N/A")))
(defun write-conf(FN conf)
  (with-temp-file FN
(dolist(conf-item conf)
(insert(format "%s=%s
" (car conf-item)
(if(cdr conf-item) (print-variable (cdr conf-item)) "")))))
 t)
#+END_SRC
We can prepare list if conses for =write-conf= using the following =make-conf= macro:
#+BEGIN_SRC emacs-lisp :tangle generated/conf.el
(defmacro make-conf(&rest variable-names)
  `(list
    ,@(mapcar (lambda(VN) `(cons (quote ,VN) ,VN)) variable-names)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1 (make-conf ~ *emacs-d*))
#+END_SRC

#+RESULTS:
:RESULTS:
((~ . /home/shalaev/) (emacs-d . ~/.emacs.d/))
:END:

* file/directory fuctions
** Common Lisp
#+BEGIN_SRC lisp :tangle
(defun FN-as-directory(FN)
  (let((PN(pathname FN)))
    (if-let((PPN(pathname-name PN)))
	(merge-pathnames
	 (make-pathname :directory `(:relative ,PPN))
	 (make-pathname :directory (pathname-directory PN)))
	PN)))
#+END_SRC
← use =uiop:ensure-directory-pathname= instead.

** ELisp
*** chgrp
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun chgrp(group file-name)
  (= 0 (call-process "chgrp" nil nil nil group (untilde file-name))))
#+END_SRC
See also =dired-do-chown=.

*** get-file-properties
This code moved here 12/28 from the [[https://github.com/chalaev/cloud][cloud project]].

BTW, =(file-exists-p FN)= produces ~nil~ if the file resides in directory with (rx) permissions →
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun get-file-properties(FN)
  (when-let((FA (and (file-exists-p FN) (file-attributes FN 'string))))
      (cl-destructuring-bind
	  (uid gid acess-time mod-time status-time fsize ms void inode fsNum)
	  (cddr FA)
(vector FN uid gid mod-time fsize (perms-from-str ms)))))
#+END_SRC

It is important that the first 6 fields are ordered as follows:
#+NAME: fileFields
| field  | num ID | description                                                       |
|--------+--------+-------------------------------------------------------------------|
| plain  |      0 | original (local) file name                                        |
| uname  |      1 | user name                                                         |
| gname  |      2 | group name                                                        |
| mtime  |      3 | modification time                                                 |
| size   |      4 | file size (should not be saved)                                   |
| modes  |      5 | access permissions                                                |
#+TBLFM: $2=@#-2

*** ensure-dir-exists
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun ensure-dir-exists (DN)
  (condition-case err
      (progn (make-directory DN t) DN)
    ;; (file-already-exists (clog :debug "%s already exists" DN))
    (file-error (clog :debug "cannot create %s" DN))))
#+END_SRC

*** FN, to-dir, and need-dir
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun FN(FN0 &rest other-FN-parts)
"concatenates arguments into file name inside (sub)directory"
(if (car other-FN-parts)
    (apply #'FN
(cons 
  (concat (file-name-as-directory FN0) (car other-FN-parts))
  (cdr other-FN-parts)))
  FN0))
(defun to-dir(root &rest dirs)
(if (car dirs)
    (apply #'to-dir
(cons 
  (file-name-as-directory (concat (file-name-as-directory root) (car dirs)))
  (cdr dirs)))
  (file-name-as-directory root)))
(defun need-dir(&rest DNs)
  (ensure-dir-exists (untilde(apply #'to-dir DNs))))
(defvar *config-directory* (need-dir *emacs-d* "conf") "where config files for el-packages are stored")
#+END_SRC

*** cat-file
(See also =echo-to-file=.)
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun cat-file(FN)
"converts file to string"
(with-temp-buffer
    (insert-file-contents FN)
    (buffer-string)))
#+END_SRC

* logging system
It is probably too small to be packaged.
** Short description
This code prints log messages to ~*Messages*~ buffer and saves them to log file =~/.emacs.d/elisp.log=.
Every message is formatted similarly to how it is done by =format= function.
** Code
Global variable =*log-level*= controls how much information should be logged: the (default) zero value means
that all types of log-messages (:debug :warning :info :error) should be logged (saved);
the value 3 means that only error messages (marked with :error) will be logged:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el :shebang ";; -*-  lexical-binding: t; -*-"
(require 'cl-lib); (at least) for decf
(defvar *log-level* 0)
#+END_SRC
Log messages are accumulated in =*log-buffer*=
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defvar *log-buffer* nil)
#+END_SRC
and once in a while (when the number of queued messages >30 or before quitting ~emacs~) appended to the file =~/.emacs.d/elisp.log=:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(let((last-FLD "")); saves last day printed to the log file
(defun log-flush(&optional log-FN)
  "save log messages to file for debugging"
  (when (= 0 *log-level*)
    (with-temp-buffer
      (let ((today-str (format-time-string "%04Y-%02m-%02d" (current-time))))
	(unless (string= today-str last-FLD)
	  (setf last-FLD today-str)
	  (insert today-str) (newline))
	(dolist (msg (reverse *log-buffer*))
	  (insert msg) (newline)))
      (append-to-file (point-min) (point-max) (or log-FN (concat *emacs-d* "elisp.log"))))
    (setf *log-buffer* nil))))
#+END_SRC
The main logging function:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun clog(level fstr &rest args)
  "simple logging function" ; level is one of → :debug :info :warning :error
(let ((log-push (lambda(msg)
  (push msg *log-buffer*)
  (when (< 30 (length *log-buffer*)) (log-flush)))))
#+END_SRC
Since we have [[https://www.emacswiki.org/emacs/EmacsLispLimitations][no multi-threading in elisp]], we do not need to introduce any lock functions.
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(when (<= *log-level* (or (pos level '(:debug :info :warning :error)) 0))
  (let ((log-msg
	   (cons
	    (concat "%s " (format-time-string "%H:%M:%S.%3N "
(apply 'encode-time (butlast (decode-time (current-time)) 3)))
		    fstr)
	    (cons (symbol-name level) args))))
      (funcall log-push (apply #'format log-msg))
      (apply #'message log-msg)))
 nil))
#+END_SRC
where I inserted =nil= at the end just for convenience, since I often use
=clog= for error messages:
#+BEGIN_SRC emacs-lisp
(if (we-got-problems)
(clog :error "we've got %d problems!" 1000)
(the-rest-of-code))
#+END_SRC
← in case of "problems" I want this code block to return =nil=.

Let us not forget to flush the log
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun on-emacs-exit()
  (clog :debug "flushing comments before quiting emacs")
  (log-flush))
#+END_SRC
before quitting emacs:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(add-hook 'kill-emacs-hook 'on-emacs-exit)
#+END_SRC

For debugging purposes (to be used in modified =defun= instead of =clog= see my =defun= re-definition):
to be used in modified =defun= instead of =clog=:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun space-log(N-of-spaces fstr)
  "prints spaces before log messages"
(let ((log-push (lambda(msg)
  (push msg *log-buffer*)
  (when (< 30 (length *log-buffer*)) (log-flush))))
(spaces ""))
(while(< 0 N-of-spaces)
 (cl-decf N-of-spaces)
 (setf spaces (concat " " spaces)))
(let((msg(concat spaces fstr)))
(funcall log-push msg)
(message msg)))
nil)
#+END_SRC

** load*
Preventing multiple load of the seame file:
#+BEGIN_SRC emacs-lisp :tangle generated/load.el :shebang ";; -*-  lexical-binding: t; -*-"
(defun barename (FN)
  (let ((SS (split-string (file-name-nondirectory FN)  "\\." t)))
    (mapconcat #'(lambda(x)x) (butlast SS) ".")))
#+END_SRC

The following function is designed to prevent multiple evaluation of one and the same file:
#+BEGIN_SRC emacs-lisp :tangle generated/load.el
(let (loaded); prevents duplicate evaluation of files
(defun load* (x &optional el-prefix)
  (let ((FN (tilde (file-chase-links (concat (or el-prefix "~/") x)))))
    (unless (member (car (last (split-string FN "\\." t))) '("el" "elc"))
      (setf FN (concat FN ".el")))
    (unless (member FN loaded) (load-file FN) (push (barename FN) loaded)))))
#+END_SRC

Usage example:
#+BEGIN_SRC emacs-lisp
(mapcar #'(lambda(x) (load* x "~/programming/"))
	'("macros" "functions" "logging"  ....))
#+END_SRC

* common lisp
** iff
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro iff (test-form then &rest else)
  "elisp-kind of if"
  (if (cdr else)
      `(if ,test-form ,then (progn ,@else))
      (if (car else)
	  `(if ,test-form ,then ,@else)
	  `(when ,test-form ,then))))
#+END_SRC

#+BEGIN_SRC lisp :results drawer
(macroexpand-1 '(iff 1 2))
#+END_SRC

#+RESULTS:
:RESULTS:
(WHEN 1 2)
T
:END:

#+BEGIN_SRC lisp :results drawer
(macroexpand-1 '(iff 1 2 3))
#+END_SRC

#+RESULTS:
:RESULTS:
(IF 1
    2
    3)
T
:END:

#+BEGIN_SRC lisp :results drawer
(macroexpand-1 '(iff 1 2 3 4))
#+END_SRC

#+RESULTS:
:RESULTS:
(IF 1
    2
    (PROGN 3 4))
T
:END:

** simple stuff
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro ifn (test ifnot &rest ifyes)
`(iff (not ,test) ,ifnot ,@ifyes))
#+END_SRC

01/18 tried to avoid strange effects in =hunchentoot= with its global variables
by using ~macroexpand-1~:
#+BEGIN_SRC lisp
(defmacro ifn (test ifnot &rest ifyes)
(macroexpand-1 `(iff (not ,test) ,ifnot ,@ifyes)))
#+END_SRC
but that did not help ☹.

So let us check if ~ifn~ works o.k. inside ~multiple-value-bind~:
#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest ifn
(let(a)
(multiple-value-bind (x y) (floor 44 11)
  (ifn(= y 0)
      (list 1 x y)
(push 1 a)
(push 2 a)
a)))
(2 1))
#+END_SRC


#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro concat (&rest strs)
  `(concatenate 'string ,@strs))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest concat
  (concat "/etc/" "dqoE.tmp")
"/etc/dqoE.tmp")
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro aset(arr pos val)
  `(setf (aref ,arr ,pos) ,val))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest aset
(aref
(let ((container (make-array 5)))
  (aset container 2 23987)
  container)
2)
23987)
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro hset(arr pos val)
  `(setf (gethash ,pos ,arr) ,val))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest hset
(gethash 'one-entry
(let ((container (make-hash-table)))
  (hset container 'one-entry 23987)
  container))
23987 t)
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro assoc-set (cons-list string-ID new-value)
  `(setf
   (cdr(assoc ,string-ID ,cons-list :test #'string=))
   ,new-value))
#+END_SRC

** file/directory fuctions
*** rmdir
#+BEGIN_SRC lisp :tangle generated/files.lisp
(defun rmdir(DN)
  (handler-case (cons t (sb-posix:rmdir DN))
    (sb-posix:syscall-error (c)
    (cons nil
      (case (sb-posix:syscall-errno c)
        (13 :permission)
        (2 :absent)
        (39 :occupied)
        (otherwise (cons :unknown (sb-posix:syscall-errno c))))))))
#+END_SRC
– expected to work on SBCL only.

*** echo-to-file
#+BEGIN_SRC lisp :tangle generated/files.lisp
(defun echo-to-file(FN str)
(handler-case 
(progn (with-open-file (stream FN
    :if-exists :append;  :overwrite
    :direction :output
    :if-does-not-exist :create)
(format stream "~a~%" str))
FN)
  (error () nil)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun echo-to-file(FN &optional str)
 (write-region (or str "") nil (untilde FN))
 (tilde FN))
(defmacro echo-to-files(FNs &optional str)
  `(dolist (FN ,FNs) (echo-to-file FN ,str)))
#+END_SRC

*** merge-paths = generalized merge-pathnames
#+BEGIN_SRC lisp :tangle generated/files.lisp
(defun merge-paths(root-dir &rest sub-dirs)
  (reduce
   #'(lambda(DN FN) (merge-pathnames FN (uiop:ensure-directory-pathname DN)))
   sub-dirs
   :initial-value root-dir))
#+END_SRC
* simple stuff
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn (test ifnot &rest ifyes)
`(if (not ,test) ,ifnot ,@ifyes))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun firstN(lista N)
  "returning first N elments of the list"
  (when (and (< 0 N) (car lista))
    (cons (car lista) (firstN (cdr lista) (1- N)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(require 'cl-lib)
(defvar *good-chars*
(let ((forbidden-symbols '(?! ?@ ?# ?$ ?% ?& ?* ?\( ?\) ?+ ?= ?/ ?{ ?} ?\[ ?\] ?: ?\; ?< ?> ?_ ?- ?| ?, ?. ?` ?' ?~ ?^ ?\")))
    (append
     (cl-loop for i from ?A to ?Z unless (member i forbidden-symbols) collect i)
     (cl-loop for i from ?a to ?z unless (member i forbidden-symbols) collect i)
     (cl-loop for i from ?0 to ?9 unless (member i forbidden-symbols) collect i)))
"safe characters for file names: everything is forbidden except for what is allowed")
(defun rand-str(N)
  (apply #'concat
     (cl-loop repeat N collect (string (nth (random (length *good-chars*)) *good-chars*)))))
#+END_SRC

There is probably some standard function or macro doing this:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro end-push (what where)
"adds an item to the end of the list, resembles 'add-to-list'"
  `(if ,where (push ,what (cdr (last ,where)))
      (push ,what ,where)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest end-push()
(should (equal '(1)
(let (container)
  (end-push 1 container)
  container)))
(should (equal '(1 2)
(let (container)
  (end-push 1 container)
  (end-push 2 container)
  container))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun land(args)
"'and' for a list"
  (cl-reduce #'(lambda(x y) (and x y)) args :initial-value t))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest land()
  (should (land '(t t t t 1 2)))
  (should (not (land '(t t t nil 1 2)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun sforward-line()
"safe forward-line"
  (if (< (line-end-position) (point-max))
     (forward-line)
     (move-end-of-line 1)))
(defun read-line(&optional max-size)
"returns current string of a buffer"
(let((max-size(or max-size 1024000)))
(if(< max-size (point-max))
   (clog :error "read-line> max-size= %d limit is too small for this large (%d) buffer" max-size (point-max))
#+END_SRC
← protection against too long strings.
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(prog1
  (buffer-substring-no-properties (line-beginning-position) (min max-size(line-end-position)))
  (sforward-line)))))
#+END_SRC

The following characters are safe for file names, as well a s for variable names in most programming languages:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defvar *safe-chars*
(let ((forbidden-symbols '(?\\ ?? ?! ?@ ?# ?$ ?% ?& ?* ?\( ?\) ?+ ?= ?/ ?{ ?} ?\[ ?\] ?: ?\; ?< ?> ?- ?| ?, ?. ?` ?' ?~ ?^ ?\")))
    (append
     (cl-loop for i from ?! to ?~ unless (member i forbidden-symbols) collect i)))
"safe characters for file names: everuthing allowed except for what is forbidden")
(defun *no-digits*(&optional symbols)
  (let((symbols(or symbols *safe-chars*)))
    (cl-loop for c in symbols when (or(< c ?0) (> c ?9)) collect c)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun intToChar(intNumer &optional symbols)
  (let*((symbols(or symbols (*no-digits*))) (lad(length symbols)) divmod)
    (cl-loop do
(setf divmod (cl-floor intNumer lad) intNumer (car divmod))
       collecting (nth (cadr divmod) symbols) into res
       while (> intNumer 0)
       finally (return (concat (reverse res))))))
#+END_SRC

* transpose
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun nth-column(n matrix)
  "returns n-th column of a matrix (n starts from zero)"
  (mapcar #'(lambda(line) (nth n line)) matrix))
(defun transpose(table)
(let((M(length(car table))) result)
(while(<= 0 (cl-decf M))
(push(nth-column M table) result))
result))
#+END_SRC

** Usage example (see also [[https://github.com/chalaev/cloud/blob/master/cloud.org][cloud sync project]])
We define several integer constants for fields in a record characterizing a file:
#+NAME: fileFields
|-------+-------+-------+-------+------+-------+--------|
| plain | uname | gname | mtime | size | modes | cipher |
|     0 |     1 |     2 |     3 |    4 |     5 |      6 |
#+TBLFM: @>=$#-1
← the numbers are assigned automatically when =C-c C-c= with cursor on TBLFM-line.

#+BEGIN_SRC emacs-lisp :tangle generated/example.el
(let
#+END_SRC
←  the list of arguments (variables) is generated automatically from the table:
#+BEGIN_SRC emacs-lisp :var ffs=fileFields :results value code  :results_switches ":tangle example.el :padline no"
(mapcar #'(lambda(l)(list(intern(car l))(cadr l))) (transpose ffs))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp :tangle example.el :padline no
((plain 0)
 (uname 1)
 (gname 2)
 (mtime 3)
 (size 4)
 (modes 5)
 (cipher 6))
#+END_SRC
Now let as add some meaningless code as an illustration:
#+BEGIN_SRC emacs-lisp :tangle example.el :padline no
(- (* modes cipher) uname gname mtime size))
#+END_SRC
Now =M-x org-babel-tangle= and then in [[file:example.el][example.el]] we find the resulting code.
This is an example of how source code can be generated in literate programming.
